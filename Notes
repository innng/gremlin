Gramática pra regressão simbólica só pra teste
Weka possui ensemble no metaclassificador
Metaclassificador pra selecionar preprocessamento
Tudo da Gui tá na cli
Fitness será rodando weKa e usando a f measure
Seleção de atributos serve pra ajudar na classificação 


<start> ::= <attSel> | <baseCl> | <metaCl> | <ensemb>

<attSel> ::= <AttributeSelectedClassifier> <eval> <search>
<baseCl> ::= <BayesNet>| <NaiveBayes> | <NaiveBayesMultinomial> | <Logistic> | <MultilayerPerceptron> | <SGD>
           | <SimpleLogistic> | <SMO> | <VotedPerceptron> | <IBk> | <KStar> | <DecisionTable> | <JRip> | <OneR>
           | <PART> | <ZeroR> | <DecisionStump> | <J48> | <LMT> | <RandomForest>  <RandomTree> | <REPTree>
<metaCl> ::= <LWL> | <AdaBoostM1> | <Bagging> | <RandomComittee> | <RandomSubSpace>
<ensemb> ::= <Stacking> | <Vote>

<eval> ::= <CfsSubsetEval>
<search> ::= <BestFirst> | <GreedySetpwise>

<CfsSubsetEval> ::= "weka.attributeSelection.CfsSubsetEval" <CfsSubsetEval-L> <CfsSubsetEval-M>
<CfsSubsetEval-L> ::= "-L" | ""
<CfsSubsetEval-M> ::= "-M" | ""

<BestFirst> ::= "weka.attributeSelection.BestFirst" <BestFirst-D> <BestFirst-N>
<BestFirst-D> ::= "RANDOM_INT [0, 2]"
<BestFirst-N> ::= "RANDOM_INT [2, 10]"

<GreedySetpwise> ::= "weka.attributeSelection.GreedyStepwise" <GreedySetpwise-B> <GreedySetpwise-C> <GreedySetpwise-R>
<GreedySetpwise-B> ::= "-B" | ""
<GreedySetpwise-C> ::= "-C" | ""
<GreedySetpwise-N> ::= "RANDOM_INT [10, 1000]"
<GreedySetpwise-R> ::= "-R" | "" <GreedySetpwise-N>

<BayesNet> ::= "weka.classifiers.bayes.BayesNet" <BayesNet-D> <BayesNet-Q>
<BayesNet-D> ::= "-D" | ""
<BayesNet-Q> ::= "weka.classifiers.bayes.net.search.local.K2" | "weka.classifiers.bayes.net.search.local.HillClimber"
               | "weka.classifiers.bayes.net.search.local.LAGDHillClimber"
               | "weka.classifiers.bayes.net.search.local.SimulatedAnnealing"
               | "weka.classifiers.bayes.net.search.local.TabuSearch" | "weka.classifiers.bayes.net.search.local.TAN"

<NaiveBayes> ::= "weka.classifiers.bayes.NaiveBayes" <NaiveBayes-D>
<NaiveBayes-D> ::= "-D" | "" <NaiveBayes-K>
<NaiveBayes-K> ::= "-K" | ""

<NaiveBayesMultinomial> ::= "weka.classifiers.bayes.NaiveBayesMultinomial"

<Logistic> ::= "weka.classifiers.functions.Logistic" <Logistic-R>
<Logistic-R> ::= "RANDOM_FLOAT [1e-12, 10]"

<MultilayerPerceptron> ::= "weka.classifiers.functions.MultilayerPerceptron" <MultilayerPerceptron-B>
                           <MultilayerPerceptron-C> <MultilayerPerceptron-D> <MultilayerPerceptron-H>
                           <MultilayerPerceptron-L> <MultilayerPerceptron-M> <MultilayerPerceptron-R>
                           <MultilayerPerceptron-S>
<MultilayerPerceptron-B> ::= "-B" | ""
<MultilayerPerceptron-C> ::= "-C" | ""
<MultilayerPerceptron-D> ::= "-D" | ""
<MultilayerPerceptron-H> ::= "a" | "i" | "o" | "t"
<MultilayerPerceptron-L> ::= "RANDOM_FLOAT [0.1, 1]"
<MultilayerPerceptron-M> ::= "RANDOM_FLOAT [0.1, 1]"
<MultilayerPerceptron-R> ::= "-R" | ""
<MultilayerPerceptron-S> ::= "1"

<SGD> ::= "weka.classifiers.functions.SGD" <SGD-F> <SGD-L> <SGD-M> <SGD-N> <SGD-R>
<SGD-F> ::= "RANDOM_INT [0, 2]"
<SGD-L> ::= "RANDOM_FLOAT [0.00001, 0.1]"
<SGD-M> ::= "-M" | ""
<SGD-N> ::= "-N" | ""
<SGD-R> ::= "RANDOM_FLOAT [1e-12, 10]"

<SimpleLogistic> ::= "weka.classifiers.functions.SimpleLogistic" <SimpleLogistic-A> <SimpleLogistic-S>
                     <SimpleLogistic-W>
<SimpleLogistic-A> ::= "-A" | ""
<SimpleLogistic-S> ::= "-S" | ""
<SimpleLogistic-W> ::= "0" | "RANDOM_FLOAT [0, 1]"

<SMO> ::= "weka.classifiers.functions.SMO" <SMO-C> <SMO-K> <SMO-N>
<SMO-C> ::= "RANDOM_FLOAT [0.5, 1.5]"
<SMO-K> ::= <SMO-NormalizedPolyKernel> | <SMO-PolyKernel> | <SMO-Puk> | <SMO-RBFKernel>
<SMO-N> ::= "RANDOM_INT [0, 2]"
<SMO-NormalizedPolyKernel> ::= "weka.classifiers.functions.supportVector.NormalizedPolyKernel"
                               <SMO-NormalizedPolyKernel-E> <SMO-NormalizedPolyKernel-L>
<SMO-NormalizedPolyKernel-E> ::= "RANDOM_FLOAT [0.2, 5]"
<SMO-NormalizedPolyKernel-L> ::= "-L" | ""
<SMO-PolyKernel> ::= "weka.classifiers.functions.supportVector.PolyKernel" <SMO-PolyKernel-E> <SMO-PolyKernel-L>
<SMO-PolyKernel-E> ::= "RANDOM_FLOAT [0.2, 5]"
<SMO-PolyKernel-L> ::= "-L" | ""
<SMO-Puk> ::= "weka.classifiers.functions.supportVector.Puk" <SMO-Puk-O> <SMO-Puk-S>
<SMO-Puk-O> ::= "RANDOM_FLOAT [0.1, 1]"
<SMO-Puk-S> ::= "RANDOM_FLOAT [0.1, 10]"
<SMO-RBFKernel> ::= "weka.classifiers.functions.supportVector.RBFKernel" <SMO-RBFKernel-G>
<SMO-RBFKernel-G> ::= "RANDOM_FLOAT [0.0001, 1]"

<VotedPerceptron> ::= "weka.classifiers.functions.VotedPerceptron" <VotedPerceptron-E> <VotedPerceptron-I>
                      <VotedPerceptron-M>
<VotedPerceptron-E> ::= "RANDOM_FLOAT [0.2, 5]"
<VotedPerceptron-I> ::= "RANDOM_INT [1, 10]"
<VotedPerceptron-M> ::= "RANDOM_INT [5000, 50000]"

<IBk> ::= "weka.classifiers.lazy.IBk" <IBk-d> <IBk-E> <IBk-K> <IBk-X>
<IBk-d> ::= "-F" | "-I" | ""
<IBk-E> ::= "-E" | ""
<IBk-K> ::= "RANDOM_INT [1, 64]"
<IBk-X> ::= "-X" | ""

<KStar> ::= "weka.classifiers.lazy.KStar" <KStar-B> <KStar-E> <KStar-M>
<KStar-B> ::= "RANDOM_INT [1, 100]"
<KStar-E> ::= "-E" | ""
<KStar-M> ::= "a" | "d" | "m" | "n"

<DecisionTable> ::= "weka.classifiers.rules.DecisionTable" <DecisionTable-E> <DecisionTable-I> <DecisionTable-S>
                    <DecisionTable-X>
<DecisionTable-E> ::= "acc" | "rmse" | "mae" | "aux"
<DecisionTable-I> ::= "-I" | ""
<DecisionTable-S> ::= "weka.attributeSelection.BestFirst" | "weka.attributeSelection.GreedyStepwise"
<DecisionTable-X> ::= "RANDOM_INT [1, 4]"

<JRip> ::= "weka.classifiers.rules.JRip" <JRip-E> <JRip-N> <JRip-O> <JRip-P>
<JRip-E> ::= "-E" | ""
<JRip-N> ::= "RANDOM_INT [1, 5]"
<JRip-O> ::= "RANDOM_INT [1, 5]"
<JRip-P> ::= "-P" | ""

<OneR> ::= "weka.classifiers.rules.OneR" <OneR-B>
<OneR-B> ::= "RANDOM_INT [1, 32]"

<PART> ::= "weka.classifiers.rules.PART" <PART-B> <PART-M> <PART-R>
<PART-B> ::= "-B" | ""
<PART-M> ::= "RANDOM_INT [1, 64]"
<PART-N> ::= "RANDOM_INT [2, 5]"
<PART-R> ::= "-R" <PART-N> | ""

<ZeroR> ::= "weka.classifiers.rules.ZeroR"

<DecisionStump> ::= "weka.classifiers.trees.DecisionStump"

<J48> ::= "weka.classifiers.trees.J48" <J48-A> <J48-B> <J48-C> <J48-J> <J48-M> <J48-O> <J48-S> <J48-U>
<J48-A> ::= "-A" | ""
<J48-B> ::= "-B" | ""
<J48-C> ::= "0" | "RANDOM_FLOAT [0, 1]"
<J48-J> ::= "-J" | ""
<J48-M> ::= "RANDOM_INT [1, 64]"
<J48-O> ::= "-O" | ""
<J48-S> ::= "-S" | ""
<J48-U> ::= "-U" | ""

<LMT> ::= "weka.classifiers.trees.LMT" <LMT-A> <LMT-B> <LMT-C> <LMT-M> <LMT-P> <LMT-R> <LMT-W>
<LMT-A> ::= "-A" | ""
<LMT-B> ::= "-B" | ""
<LMT-C> ::= "-C" | ""
<LMT-M> ::= "RANDOM_INT [1, 64]"
<LMT-P> ::= "-P" | ""
<LMT-R> ::= "-R" | ""
<LMT-W> ::= "0" | "RANDOM_FLOAT [0, 1]"

<RandomForest> ::= "weka.classifiers.trees.RandomForest" <RandomForest-depth> <RandomForest-I> <RandomForest-K>
<RandomForest-depth> ::= "0" | "RANDOM_INT [1, 20]"
<RandomForest-I> ::= "RANDOM_INT [2, 256]"
<RandomForest-K> ::= "0" | "RANDOM_INT [1, 32]"

<RandomTree> ::= "weka.classifiers.trees.RandomTree" <RandomTree-depth> <RandomTree-K> <RandomTree-M> <RandomTree-N>
                 <RandomTree-U>
<RandomTree-depth> ::= "0" | "RANDOM_INT [2, 20]"
<RandomTree-K> ::= "0" | "RANDOM_INT [2, 32]"
<RandomTree-M> ::= "RANDOM_INT [1, 64]"
<RandomTree-N> ::= "0" | "RANDOM_INT [2, 5]"
<RandomTree-U> ::= "-U" | ""

<REPTree> ::= "weka.classifiers.trees.REPTree" <REPTree-L> <REPTree-M> <REPTree-P> <REPTree-V>
<REPTree-L> ::= "-1" | "RANDOM_INT [2,20]"
<REPTree-M> ::= "RANDOM_INT [1, 64]"
<REPTree-P> ::= "-P" | ""
<REPTree-V> ::= "RANDOM_FLOAT [1e-5, 1e-1]"

<Stacking> ::= "weka.classifiers.meta.Stacking" <Stacking-S> <Stacking-X>
<Stacking-S> ::= "1"
<Stacking-X> ::= "10"

<Vote> ::= "weka.classifiers.meta.Vote" <Vote-R> <Vote-S>
<Vote-R> ::= "AVG" | "PROD" | "MAJ" | "MIN" | "MAX"
<Vote-S> ::= "1"

<LWL> ::= "weka.classifiers.lazy.LWL"
//        * KNN (-K)
//            * K_HIDDEN (0, 1; 0)
//                * 1_K (-1, 10, 30, 60, 90, 120; -1)
//        * classifier (-W)
//        * nearestNeighbourSearchAlgorithm (-A)
//            * (LinearNNSearch; LinearNNSearch)
//        * weightingKernel (-U)
//            * U_HIDDEN (0, 1; 0)
//                * 1_U (0, 1, 2, 3, 4; 0)
//        * regras:
//            * `1_K` se K_HIDDEN 1
//            * `1_U` se K_HIDDEN 0
//            * `1_U` se U_HIDDEN 1
//            * `1_K` se U_HIDDEN 0

<AdaBoostM1> ::=
//    * AdaBoostM1
//        * classifier (-W)
//        * numIterations (-I)
//            * ([2, 128]; 10) inteiro
//        * seed (-S)
//            * (1; 1)
//        * useResampling (-Q)
//            * (true, false; false)
//        * weightThreshold (-P)
//            * p_HIDDEN (0, 1; 0)
//                * 1_P (100; 100)
//                * `2_INT_P` ([50, 100]; 100)
//            * regras:
//                * `1_P` se p_HIDDEN 0
//                * `2_INT_P` se p_HIDDEN 1

<AttributeSelectedClassifier> ::=
//    * AttributeSelectedClassifier
//        * classifier (-W)
//        * evaluator (-E)
//            * (CfsSubsetEval; CfsSubsetEval)
//        * search (-S)
//            * (BestFirst, GreedyStepwise; BestFirst)

<Bagging> ::=
//    * Bagging
//        * bagSizePercent (-P)
//            * ([10, 100]; 100) inteiro
//        * calcOutOfBag (-O)
//            * (true, false; false)
//        * classifier (-W)
//        * numIterations (-I)
//            * ([2, 128]; 10) inteiro
//        * seed (-1)
//            * (1; 1)
//        * regras:
//            * O se INT_P 100

<RandomComittee> ::=
//    * RandomComittee
//        * classifier (-W)
//        * numIterations (-I)
//            * ([2, 64]; 10) inteiro
//        * seed (-S)
//            * (1; 1)

<RandomSubSpace> ::=
//    * RandomSubSpace
//        * classifier (-W)
//        * numIterations (-I)
//            * ([2, 64]; 10) inteiro
//        * seed (-S)
//            * (1; 1)
//        * subSpaceSize (-P)
//            * ([0.1, 1]; 0.5)
